\section{Deployment, configuration}
\label{sec:deployment-configuration}

Deploying, configuring and operating a distributed pattern matcher is a complex task. In the following, we will break down this task to smaller steps and present our tools for solving them. 

\subsection{Tooling}

We aimed to build \iqd{} on top of \eiq{}'s pattern language (IQPL) and its Rete net generator. For the allocation of Rete nodes, we created an Eclipse-based editor and viewer.

\subsection{Degrees of freedom}

The deployment and configuration of a distributed pattern matcher involves many degrees of freedom:

\begin{itemize}
  \item We may choose different database implementations due to the \iqd{}'s backend-agnostic nature. Until now, we experimented with property graph databases (Neo4j, Titan) and triplestores (4store).
  \item We may use different database sharding strategies (e.g.\ random partitioners or more sophisticated sharding methods based on domain-specific knowledge).
  \item We may choose diffent strategies to allocate the Rete nodes. Note that in theory, this is orthogonal to the database's sharding strategy. However, we expect that keeping the Rete network's type indexer nodes and the instances of the given type on the same server would decrease the initialization time significantly.
\end{itemize}
 
\subsection{Workflow}
\label{subsec:workflow}
 
In the following part, we will describe the workflow behind the pattern matching process. Starting from a metamodel, an instance model and a graph pattern, we will cover the problem pieces that need to be solved for setting up an incremental, distributed pattern matcher. The workflow is shown on \figref{recipe}.

\myFigureSmall{recipe}{The workflow of \eiq{} (blue) and \iqd{} (green)}

\subsubsection{Analyze the metamodel and the query}

\paragraph{Task.} First, we determine the constraints defined by the query pattern. The matches satisfying these constraints will define the results of the query.

\paragraph{Implementation.} The pattern is defined in an IQPL (\iq{} Pattern Language) text file. Using Xtext \cite{Xtext}, an Eclipse-based framework for creating domain-specific languages, the textual representation of the pattern is parsed to an EMF model. Based on the EMF model's pattern and the metamodel, a constraint network called \textit{PSystem} (short for \textit{Pattern System}) is generated. 

\subsubsection{Build a Rete layout}

\paragraph{Task.} To allow incremental query evaluation, we create a Rete net based on the constraints derived from the query.

\paragraph{Implementation.} As we mentioned earlier, we aim to reuse as much of \eiq{}'s existing code base as possible. As part of this attempt, we introduced the concept of \textit{Rete recipe}s which define the layout of a Rete network.    

\subsubsection{Allocate the Rete network in the cloud's nodes} 

\paragraph{Task.} Because of its single workstation nature, \eiq{} simply unfolds the Rete net based on the derived Rete recipe. At the same time, \iqd{} operates in a distributed environment where local resource exhaustion, network latency and throughput are critical aspects. 

\paragraph{Implementation.} Currently, the allocation of the Rete nodes is done manually. To address this limitation, we plan to utilize Constraint Satisfaction Problem (CSP) solvers, or dynamic techniques like Design Space Exploration (DSE)~\cite{DSE11}. 

\subsubsection{Bootstrap the system}

\paragraph{Task.} Based on the Rete network's allocation, we have to deply the Rete nodes in the distributed systems. After the successful deployment, the Rete network has to be initialised. Due to the Rete algorithm's asynchronous nature, it uses a termination protocol to signal when the data processing is finished. 

\paragraph{Implementation.} In \iqd{}'s prototype, both the bootstrapping and the Rete network's operation is carried out automatically. The Akka actors representing the Rete nodes are deployed and initiated using Akka's \textit{programmatic remote deployment} feature. 

