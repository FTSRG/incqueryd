\chapter{Conclusions}
\label{chap:conclusions}

\section{Summary of contributions}


We presented \iqd{}, a novel approach to adapt distributed incremental query techniques to large and complex model driven software engineering scenarios. Our proposal is based on a distributed Rete network that is decoupled from sharded graph databases by a middleware layer, and its feasibility has been evaluated using a benchmarking scenario of on-the-fly well-formedness validation of software design models. The results are promising as they show nearly instantaneous query re-evaluation as model sizes grow well beyond $10^7$ elements.

% TODO separate


During the research and development of \iqd{}'s prototype, I achieved the following results.

\subsection{Scientific contributions}

\begin{itemize}
  \item I implemented a \emph{distributed, asynchronous version of the Rete algorithm} with a termination protocol. Based on the Rete algorithm, I created a \emph{distributed incremental query engine's prototype}, which is not only detached from the data storage backend, but also agnostic to the storage backend's data model. To prove this, the query engine was tested with both property graphs and RDF graphs. 
  \item Based on \eiq{} and István Ráth's work, I created an \emph{Eclipse-based environment} to provide automated deployment of the Rete network. This allows the user to define complex queries in IQPL, a high-level pattern language. % TODO SzG define own work
  \item I conducted a benchmark to measure \iqd{}'s \emph{response time and scalability characteristics}. For the benchmark's baseline, I created \emph{distributed non-incremental benchmark scenarios}, with Neo4j and 4store. 
\end{itemize}

\subsection{Practical accomplishments}

\begin{itemize}
  \item I extended the \tb{} with a \emph{new instance model generator}, which can produce property graphs and serialize them in various formats: \graphml{}, Blueprints \graphson{} and Faunus \graphson{}. % (\autoref{sec:property-graph-formats}).
  \item I extended the \tb{} to work in a distributed environment. 
  \item I implemented \iqd{}'s prototype, including the storage, the middleware and the query layer. I wrote more than 3000 lines of Java code and approximately 500 lines of configuration and deployment scripts.
  \item I experimented with modern non-relational database management systems with a focus on NoSQL graph databases and triple stores. I created the connector class in \iqd{}'s middleware and formulated the necessary the Gremlin queries.
  \begin{itemize}
    \item I implemented scripts to install the \emph{Titan graph database and its ecosystem} on a cluster. Titan's ecosystem includes technologies on different maturity levels, including the Apache Cassandra database, the Apache Hadoop MapReduce framework with the HDFS distributed file system, the TinkerPop graph framework and the Faunus graph analytics engine.
    \item I implemented scripts to install the \emph{4store triplestore} on a cluster. I created the connector class in \iqd{}'s middleware and formulated the necessary the SPARQL queries. 
    \item I deployed a manually sharded \emph{Neo4j cluster}. I created the connector class in \iqd{}'s middleware to access Neo4j and formulated the appropriate Cypher queries.
  \end{itemize}
  \item I implemented scripts for \emph{automating the benchmark} and \emph{operating a cluster of Akka microkernels}.
\end{itemize}

\section{Limitations}

\begin{itemize}
  \item manual allocation of Rete nodes
  \item only a subset of Rete nodes implemented 
  \item lack of complete tooling   
\end{itemize}

\section{Future work}
\label{sec:future-work}

For future work, we plan on providing more sophisticated automation for sharded Ecore models, and further exploring advanced optimization challenges such as dynamic reconfiguration and fault tolerance.
We also plan experiment with programming languages that are better suited to asynchronous algorithms (e.g.\ Erlang and Scala) and try different database systems (e.g. MongoDB) as our storage layer.

* functional programming, e.g.\ Scala
* node sharding
* CSP, DSE
* live monitoring
* etc

