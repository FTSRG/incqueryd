\chapter{Conclusions}
\label{chap:conclusions}

\section{Summary of contributions}

\subsection{Own work}

TrainBenchmark generator for property graphs (GraphML, Blueprints GraphSON and Faunus GraphSON formats)

adapted the Rete algorithm for property graphs and RDF graphs

detached, backend-agnostic incremental query engine 

working prototype for a distributed Rete network, ''proof of concept''

tooling: automated deployment of the Rete network

over 3000 LoC of Java code, lots of configuration and deployment shell scripts (~500 LoC)

technological work:

- Titan ecosystem (Cassandra, Hadoop, HDFS, Faunus), Gremlin queries
- Neo4j, Cypher queries
- 4store, SPARQL queries
- Akka 

% scientific contributions
% * backend-agnostic distributed incremental query service
%   * architecture (query as a separate service from DB backends)
%   * initialization, indexing
%     * standalone, Rete-based distributed indexing service
%     * incremental maintenance (when using our middleware API)
%   * database management
%     * notification (when using our middleware API)
%   * incremental query
%     * define complex queries in a high-level language
%     * efficient change propagation
%     * low reponse time
%   * tooling (automation as motivation)
%     * languages (for configuration)
%     * code generation
%     * configuration / deployment

\section{Limitations}

\section{Future directions}

We presented \iqd{}, a novel approach to adapt distributed incremental query techniques to large and complex model driven software engineering scenarios. Our proposal is based on a distributed Rete network that is decoupled from sharded graph databases by a middleware layer, and its feasibility has been evaluated using a benchmarking scenario of on-the-fly well-formedness validation of software design models. The results are promising as they show nearly instantaneous query re-evaluation as model sizes grow well beyond $10^7$ elements.
For future work, we plan on providing more sophisticated automation for sharded Ecore models, and further exploring advanced optimization challenges such as dynamic reconfiguration and fault tolerance.
We also plan experiment with programming languages that are better suited to asynchronous algorithms (e.g.\ Erlang and Scala) and try different database systems (e.g. 10gen MongoDB) as our storage layer.

