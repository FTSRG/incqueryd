\chapter{Conclusions}
\label{chap:conclusions}

This chapter summarizes the contributions presented in the report. 

\section{Summary of Contributions}
\label{summary}

We presented \iqd{}, a novel approach to adapt distributed incremental query techniques to large and complex model driven software engineering scenarios. Our proposal is based on a distributed Rete network that is decoupled from sharded graph databases by a middleware layer. The feasibility of the approach has been evaluated using a benchmarking scenario of on-the-fly well-formedness validation of software design models. The results are promising as they show nearly instantaneous query re-evaluation as model sizes grow well beyond 50 million elements.

During the research and development of \iqd{} so far, I achieved the following results.

\subsection{Scientific Contributions}

I achieved the following scientific contributions:

\begin{itemize}
  \item I proposed a novel architecture for building a distributed, scalable, incremental graph query engine over different storage backends. The architecture was published in \cite{Izso:2013:IIG:2487766.2487772}. 
  \item I designed and implemented a \emph{distributed, asynchronous version of the Rete algorithm}. 
  \item I extended the termination protocol used \eiq{} to work in a distributed environment. 
  \item I extended the \tb{} to work in a distributed environment.  
  \item I conducted a benchmark to measure \iqd{}'s \emph{response time and scalability characteristics}. For the benchmark's baseline, I created \emph{distributed non-incremental benchmark scenarios}. 
\end{itemize}

\subsection{Practical Accomplishments}

I achieved the following practical accomplishements:

\begin{itemize}
  \item Based on the Rete algorithm, I created a \emph{distributed incremental query engine's prototype}, which is not only detached from the data storage backend, but also agnostic to the storage backend's data model. To prove this, the query engine was tested with both property graphs and RDF graphs.
  \item I extended the \tb{} with a \emph{new instance model generator}, which can produce property graphs and serialize them in various formats: \graphml{}, Blueprints \graphson{} and Faunus \graphson{}.
  \item I developed \iqd{}'s prototype, including the query layer, the middleware and the integration to different storage technologies. I wrote more than 3000 lines of Java code and approximately 500 lines of configuration and deployment scripts.
  \item I elaborated automated deployment tools based on \eiq{}'s existing technologies.
  \item I experimented with modern non-relational database management systems with a focus on NoSQL graph databases and triple stores. For the purpose of benchmarking different tools, I created scripts to install various graph storages. 
  \begin{itemize}
    \item I deployed a manually sharded \emph{Neo4j} cluster. I formulated the appropriate Cypher queries and created the connector class in \iqd{}'s middleware to access Neo4j.
    \item I implemented scripts to install the \emph{Titan graph database and its ecosystem} on a cluster. Titan's ecosystem includes technologies on different maturity levels, including the Apache Cassandra database, the Apache Hadoop MapReduce framework with the HDFS distributed file system, the TinkerPop graph framework and the Faunus graph analytics engine. I formulated the necessary the Gremlin queries and created the connector class in \iqd{}'s middleware.
    \item I implemented scripts to install the \emph{4store triplestore} on a cluster. I formulated the necessary the SPARQL queries and created the connector class in \iqd{}'s middleware. 
  \end{itemize}
  \item The analysis of the results confirmed the feasibility of the approach and showed its superiority to current open-source graph query engines.
  \item I implemented scripts for \emph{automating the benchmark} and \emph{operating a cluster of Akka microkernels}.
\end{itemize}

The current paper significantly extends the contributions of our earlier results~\cite{Izso:2013:IIG:2487766.2487772}. This report discusses the theoretical background and practical difficulties, including the detailed presentation of the architecture (\autoref{chap:overview}). The benchmark evaluation has been extended to include truly distributed graph database backends (\autoref{chap:evaluation}) as \iqd, as presented here, features backends with automatic sharding, automatic deployment of the Rete nodes and an Eclipse-based tooling environment. 

\section{Limitations}

\iqd{}'s current implementation has some limitations, the most important ones are the following.

\begin{enumerate}
  \item The Rete nodes are allocated manually. The user has to define the mapping between the Rete network and the infrastructure. However, given a mapping, the system is capable of automatically deploying the Rete network.
  \item Only a subset of the nodes defined in the Rete algorithm are implemented. For example, the current implementation does not support recursive patterns, checking property conditions and transitive closures.
  \item The Eclipse-based tooling does not cover the whole workflow. The user is required to do some manual work, e.g.\ running scripts manually.
\end{enumerate}

\section{Future work}
\label{future-work}

For future work, we plan to address the aforementioned limitations.

\begin{enumerate}
  \item The allocation of the Rete nodes will be supported using techniques like CSP (Constraint Satisfaction Problem) solvers and DSE (Design Space Exploration) \cite{DSE11}. We plan to further explore advanced optimization challenges such as dynamic reconfiguration and fault tolerance.
  \item We will complete the implementation of the nodes defined in Rete algorithm.
  \item The tooling in under active development with plans for a \emph{live monitoring} feature.
\end{enumerate}

We also plan to extend the distributed \tb{} to model different real-world workloads, e.g.\ simulating multiple users issuing concurrent requests. We will add a \emph{unique identifier generator} to the middleware, which will allow us to use multiple data sources (which may have different element with the same identifiers).   

Another direction is experimenting with programming languages that are better suited to asynchronous algorithms, e.g.\ Erlang and Scala, a Java-based functional object-oriented programming language.
For our storage layer, we plan to test distributed in-memory databases, e.g.\ Hazelcast~\cite{Hazelcast} and to extend proven solutions, like Titan, with a distributed notification layer.
Also, we are constantly looking for alternative scalable persistent graph database technologies. 

\section{Acknowledgements}

I would like to thank my supervisors Dr.~István Ráth, Benedek Izsó and Dr.~Dániel Varró for their advice and enthusiasm. I would also like to thank Dr.~Gábor Bergmann and Dr.~Ákos Horváth.
