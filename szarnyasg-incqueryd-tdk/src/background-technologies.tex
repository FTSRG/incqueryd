\chapter{Background technologies}

Implementing a scalable graph pattern matcher requires a wide range of technologies. Careful selection of the used technologies is critical to the project's success. For \iqd, we were looking for technologies that were designed with scalability in mind and have been deployed in large-scale distributed systems successfully. To avoid licensing issues and costs, we were looking for free and open-source solutions. 

%scalable pattern matcher technology background
%TODO Linux

\section{Big Data and the NoSQL movement}

Since the 1980s, database management systems based on the relational data model \cite{Codd:1970:RMD:362384.362685} dominated the database market. Relational databases have a number of important advantages: precise mathematical background, understandibility, mature tooling, etc. However, due to the strongly connected nature of their data model, relational databases often have scalability issues [citation].

In the last decade, organizations often struggled to store and process the huge amounts of data they produced. This problem introduces a diverse palette of scientific and engineering challenges, often called \emph{Big Data} challenges. 

Big Data challenges spawned dozens of new database management systems. Typically, these systems broke up with the strictness of the relational data model and utilized simpler, more scalable data models. These systems dropped support for SQL query language used in relational databases and hence were called \emph{NoSQL databases}\footnote{The community now mostly translates NoSQL as ''not only SQL''.} \cite{NoSQL}. During the development of \iqd's propotype, we experimented with numerous NoSQL databases.

\section{Graph models}

The graph is a well-known mathematical concept widely used in computer science. For our work, it's important to distinguish between the different graph data models.

\myFigure{graph-data-models}{Different graph data models \cite{DBLP:journals/corr/abs-1006-2361}}

\subsection{Graph databases}

nosql movement's databases

\subsubsection{Property graph data model}

typical nosql data model

\subsubsection{TinkerPop}

property graph implementation

\subsection{Triplestores}

semantic technologies, different technological space

\subsubsection{RDF data model}

RDF, OWL

\section{Technologies}

In the following section we summarize the core technologies used in \iqd's prototype implementation. We briefly introduce the goals of each technology, with particular emphasis on the scalability aspects.

\subsection{Cassandra}

Cassandra (\figref{cassandra-logo}) is one of the most widely used NoSQL databases \cite{Cassandra}. Originally developed by Facebook \cite{Lakshman:2010:CDS:1773912.1773922}, Cassandra is now an open-source Apache project.

Cassandra's data model is called \emph{column family}. A column family is similar to a table of a relational database: it consists of rows and columns. However, unlike in a relational database's table, the rows do not have to have the same fixed set of columns. Instead, each row can have a different set of columns. This makes the data structure more dynamic and avoids the plethora of problems associated with NULL values.

\myFigure{cassandra-logo}{The logo of Apache Cassandra}

To distribute the data across the cluster, Cassandra uses a partitioner mechanism. The simplest partitioners distribute the rows evenly based on their hash values. Currently, Cassandra provides \emph{RandomPartitioner} (MD5 hash) and \emph{Murmur3Partitioner} (Murmur3 hash).

%TODO cover virtual nodes
%\myFigure{cassandra-vnodes}{Cassandra's ring for data partitioning}

\subsection{Hadoop}

Hadoop is an open-source, distributed data processing framework inspired by Google's publications about MapReduce \cite{Dean:2008:MSD:1327452.1327492} and the Google File System \cite{Ghemawat:2003:GFS:945445.945450}. Originally developed at Yahoo!, Hadoop is now an Apache project \cite{Hadoop}. Like Google's systems, Hadoop is designed to run on commodity hardware (i.e. server clusters built from commercial off-the-shelf products). Hadoop provides a distributed file system (HDFS) and a column family database (HBase). All software in the Hadoop framework is written in Java.

The MapReduce paradigm provides parallel, asynchronous processing of data. As the name implies, MapReduce consists of two phases: the \emph{map} function processes each item of a list. The resulted list, which is aggregated by the \emph{reduce} function.

A typical small Hadoop cluster consists of a single master node which is responsible for the coordination of the cluster and worker nodes which deal with the data processing. The MapReduce is coordinated by the master's \emph{job tracker} and processed by the slave nodes' \emph{task tracker} modules (\figref{hadoop-architecture}).

\myFigure{hadoop-architecture}{Hadoop's architecture}

\subsubsection{HDFS}

The Hadoop Distributed File System (HDFS) is an open-source, distributed file system, inspired by the Google File System and written specifically for Hadoop \cite{Hadoop}. Unlike other distributed file systems (e.g. Lustre), which require expensive hardware components, HDFS was designed for commodity hardware.

HDFS integrated with Hadoop's architecture (\figref{hdfs}). The \emph{NameNode} is responsible for storing the metadata of the files and the location of the replicas. The data is stored by the \emph{DataNode}s.

\myFigure{hdfs}{HDFS' architecture}

\subsubsection{HBase}

HBase is an open-source, distributed column family database. It is developed as part of the Hadoop project and runs on top of HDFS. The tables in an HBase database can serve as the input and the output for MapReduce jobs run in Hadoop.

\subsection{Neo4j}

Neo4j, developed by Neo Technology, is the most popular NoSQL graph database. Neo4j implements TinkerPop's Blueprints property graph data model along with Gremlin. It also provides Cypher, a declarative query language for graph pattern matching. 

Neo4j is one of the most mature NoSQL databases. It's well documented and provides ample tooling. However, it's scalability features are limited: instead of sharding, it only supports replication of data to create a highly available cluster. Of course, the scalability limitations are a hot topic in Neo4j's development. The company makes serious efforts to improve Neo4j's scalability in an ongoing project called Rassilon \cite{rassilon}.

\myFigure{neo4j-logo}{The logo of Neo4j}

\subsection{Titan}

Titan (\figref{titan-logo}) is an open-source, distributed, scalable graph database from Aurelius, the creators of the TinkerPop framework. Unlike Neo4j, Titan is not a standalone database. Instead, it builds on top of existing NoSQL database technologies and leverages Hadoop's MapReduce capabilities. Titan supports various storage backends, including Cassandra and HBase.

\myFigure{titan-logo}{The logo of Titan}

\subsubsection{Mapping and sharding}

To store the graph, Titan maps each vertex to a row of a column family (\figref{titan-cassandra-mapping}). The row stores the identifer and the properties of the vertex, along both the incoming and outgoing edges' identifiers, labels and properties.

Titan uses the storage backend's partitioner (e.g. Cassandra's RandomPartitioner) to shard the data. A more sophisticated partitioning system that will allow for partitioning based on the graph's domain and its connectivity is under implementation, but not yet available.

\myFigure{titan-cassandra-mapping}{Titan graph vertex stored in Cassandra as a row}

\subsubsection{Deployment}

Titan can be deployed in different ways according to the needs of the application. For \iqd's prototype, we used Titan in \textit{remote server mode} (\figref{titan-modes-distributed}). In this setup, Titan runs in the same JVM as the application and communicates with the Cassandra cluster on a low-level protocol (e.g. Thrift).

\myFigure{titan-modes-distributed}{Using Titan with Cassandra in remote server mode}

\subsubsection{Faunus}

Although Titan was designed with scalability in mind, it's query engine does not work in a parallel fashion. Also, it's unable to cope with queries resulting in millions of graph elements. To address this shortcoming, Aurelius developed a Hadoop-based graph analytics engine, Faunus (\figref{faunus-logo}).

Faunus has its own format called Faunus GraphSON. The Faunus GraphSON format is vertex-centric, meaning that each row represents a vertex of the graph. This way, Hadoop is able to efficiently split the input file and parallelize the load process.

\myFigure{faunus-logo}{The logo of Faunus}

It's important to note that Faunus always traverses the whole graph and does not use its indices. This makes it slow for retrieving nodes or edges by type (see our typical workload at XXX).

\subsection{4store}

4store is an open-source, distributed triplestore created by Garlik \cite{4store}. Unlike the other tools discussed earlier, 4store is written in C. While 4store is primarily applied for semantic web projects, it's maturity and scalability made it an appropriate storage backend for \iqd's prototype.

Similar to Titan's partitioning, 4store's sharding mechanism (called \emph{segmenting}) distributes the RDF resources evenly across the cluster. However, unlike Titan, 4store's data model is a semantic RDF graph. Hence, 4store's input format is RDF/OWL.

\myFigure{4s-cluster}{4store's distributed architecture \cite{4store}}

\section{Asynchronous messaging}

Implementing a distributed, concurrent system requires a messaging framework. Because of the nature of the Rete algorithm (\ref{subsec:rete}) \iqd\ requires a distributed, asynchronous messaging framework.

\subsection{Akka}

\myFigure{akka-logo}{The logo of Akka}

Akka is an open-source, fault-tolerant, distributed, asynchronous messaging framework developed by Typesafe \figref{akka-logo}. Akka is implemented in Scala, a functional and object-oriented programming language which runs on the Java Virtual Machine (JVM). Akka provides language bindings for both Java and Scala.

%\myFigure{akka-actor-path}{Determining an actor's path in Akka}

Akka provides strong support for remoting. Actors have both a logical and a physical path (\figref{akka-remote-deployment}). This way, they can be transparently moved between nodes of the cluster.

\myFigure{akka-remote-deployment}{Deploying a remote actor in Akka}

\section{Eclipse-based technologies}

Eclipse is a free, open-source software development environment and a platform for plug-in development. Members of the Eclipse Foundation include industry giants like IBM, Intel, Google and SAP.

\iqd's single workstation predecessor, \eiq\ is built around Eclipse-based technologies. To reap the benefits of a mutual code base, we design \iqd\ to use as much of \eiq's components as possible. In the following section, we introduce the Eclipse-based technologies most important for our work.  

\subsection{EMF}

Eclipse comes with its own modeling technologies called EMF (Eclipse Modeling Framework). EMF provides a metamodel (Ecore) for designing applications and a code generation facility to produce the Java classes for the model.

\subsection{\eiq}

\eiq is developed by the Fault Tolerant Systems Research Group (FTSRG) in the Budapest University of Technology and Economics. 

\myFigure{incquery-architecture}{\eiq's architecture}

