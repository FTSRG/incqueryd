\chapter{Background technologies}

Implementing a scalable graph pattern matcher requires a wide range of technologies. Careful selection of the technologies is critical to the project's success. For \iqd, we were looking for technologies that were designed with scalability in mind and have been deployed in large-scale distributed systems successfully. To avoid licensing issues and costs, our search criteria included that the technologies must be free and open-source solutions. 

%scalable pattern matcher technology background
%TODO Linux

\section{Big Data and the NoSQL movement}

Since the 1980s, database management systems based on the relational data model~\cite{Codd:1970:RMD:362384.362685} dominated the database market. Relational databases have a number of important advantages: precise mathematical background, understandibility, mature tooling and so on. However, due to the strongly connected nature of their data model, relational databases often have scalability issues~\cite{Sakr13}. % TODO find a better citation

In the last decade, organizations often struggled to store and process the huge amounts of data they produced. This problem introduces a diverse palette of scientific and engineering challenges, often called \emph{Big Data} challenges. 

Big Data challenges spawned dozens of new database management systems. Typically, these systems broke with the strictness of the relational data model and utilized simpler, more scalable data models. These systems dropped support for the SQL query language used in relational databases and hence were called \emph{NoSQL databases}\footnote{The community now mostly translates NoSQL as ''not only SQL''.}~\cite{NoSQL}. During the development of \iqd's propotype, we experimented with numerous NoSQL databases.

\section{Graph models}

The graph is a well-known mathematical concept widely used in computer science. For our work, it is important to distinguish between different graph data models.

\myFigure{graph-data-models}{Different graph data models~\cite{DBLP:journals/corr/abs-1006-2361}}

\subsection{Graph models}

The most basic graph model is the \emph{simple graph}, formally defined as $G = (V, E)$, where $V$ is the set of vertices and $E \subseteq V \times V$ is the set of edges. Simple graphs are sometimes referred as textbook-style graphs because they are an integral part of academic literature. Simple graphs are useful for modeling homogeneous systems and have plenty of algorithms for processing.

Simple graphs can be extended in several different ways (\figref{graph-data-models}). To describe the connections in more detail, we may add directionality to edges (\emph{directed graph}), allow loops and multiple edges (\emph{multi-graph}). To allow different connections, we may label the edges (\emph{labeled graph} or \emph{semantic graph}). \emph{RDF graph}s use URIs instead of labels, otherwise they have similar expressive power as labeled graphs. \emph{Property graph}s add even more possibilites by introducing properties. Each graph element, both vertices and edges can be described with a collection of properties. The properties are key--value pairs, e.g.\ %$\mathit{type} = \mathrm{Person}$, $\mathit{name} = \mathrm{John}$, $\mathit{age} = 34$.
\texttt{type = 'Person'}, \texttt{name = 'John'}, \texttt{age = 34}. 
Property graphs are powerful enough to describe Java objects or EMF instance models (\autoref{subsec:EMF}).

\subsubsection{TinkerPop}

The \textit{TinkerPop} framework is an open-source software stack for graph storage and processing. TinkerPop includes Blueprints, a property graph model interface. Blueprints fulfills the same role for graph databases as JDBC does for relational databases. Most NoSQL graph databases implement the property graph interface provided by Blueprints, including Neo4j (\autoref{subsec:neo4j}), Titan (\autoref{subsec:titan}), DEX~\cite{DEX}, InfiniteGraph~\cite{InfiniteGraph} and OrientDB~\cite{OrientDB}.

\myFigure{tinkerpop-stack}{The TinkerPop software stack}

TinkerPop also introduces a graph query language, \textit{Gremlin}. Gremlin is a domain-specific language based on Groovy, a Java-like dynamic language which runs on the Java Virtual Machine. Unlike most query languages, Gremlin is an imperative language with a strong focus on graph traversals. Gremlin is based on \textit{Pipes}, TinkerPop's dataflow processing framework. Besides the traversing, Gremlin capable of analyzing and manipulating the graph as well.

TinkerPop also provides a graph server (\textit{Rexster}), a set of graph algorithms tailored for property graphs (\textit{Furnace}) and an object-graph mapper (\textit{Frames}). The TinkerPop software stack is shown on \figref{tinkerpop-stack}.


\subsection{Triplestores}

Triplestores are tailored to store and process triples efficiently. A triple is a data entity composed of a subject, a predicate and an object, e.g.\ ''John instanceof Person'', ''John is 34''. Triplestores are mostly used in semantic technology projects. Also, some triplestores are capable of \emph{reasoning}, i.e.\ inferring logical consequences from a set of facts or axioms. 

Triplestores use the RDF (Resource Description Framework) data model. Although the RDF data model has less expressive power than the property graph, by introducing additional resources for each property, a property graph can be easily mapped to a RDF. Triplestores are usually queried via the RDF format's query language, SPARQL (recursive acronym for SPARQL Protocol and RDF Query Language). 

\section{NoSQL technologies}

In the following section we summarize the core technologies used in \iqd's prototype implementation. We briefly introduce the goals of each technology, with particular emphasis on the scalability aspects.

\subsection{Cassandra}

Cassandra %(\figref{cassandra-logo}) 
is one of the most widely used NoSQL databases~\cite{Cassandra}. Originally developed by Facebook~\cite{Lakshman:2010:CDS:1773912.1773922}, Cassandra is now an open-source Apache project.

Cassandra's data model is called \emph{column family}. A column family is similar to a table of a relational database: it consists of rows and columns. However, unlike in a relational database's table, the rows do not have to have the same fixed set of columns. Instead, each row can have a different set of columns. This makes the data structure more dynamic and avoids the plethora of problems associated with NULL values.

%\myFigure{cassandra-logo}{The logo of Apache Cassandra}

To distribute the data across the cluster, Cassandra uses a partitioner mechanism. The simplest partitioners distribute the rows evenly based on their hash values. Currently, Cassandra provides \emph{RandomPartitioner} (MD5 hash) and \emph{Murmur3Partitioner} (Murmur3 hash).

Cassandra has sophisticated fault-tolerance mechanism. It allows the application to balance between availability and consistency by allowing it to tune the consistency constraints. Cassandra is written in Java.

%TODO cover virtual nodes
%\myFigure{cassandra-vnodes}{Cassandra's ring for data partitioning}

\subsection{Hadoop}

Hadoop is an open-source, distributed data processing framework inspired by Google's publications about MapReduce~\cite{Dean:2008:MSD:1327452.1327492} and the Google File System~\cite{Ghemawat:2003:GFS:945445.945450}. Originally developed at Yahoo!, Hadoop is now an Apache project~\cite{Hadoop}. Like Google's systems, Hadoop is designed to run on commodity hardware, i.e.\ server clusters built from commercial off-the-shelf products. Hadoop provides a distributed file system (HDFS) and a column family database (HBase). All software in the Hadoop framework is written in Java.

The MapReduce paradigm defines a parallel, asynchronous way of processing the data. As the name implies, MapReduce consists of two phases: the \emph{map} function processes each item of a list. The resulted list is then aggregated by the \emph{reduce} function.

A typical small Hadoop cluster consists of a single master node which is responsible for the coordination of the cluster and worker nodes which deal with the data processing. The MapReduce job is coordinated by the master's \emph{job tracker} and processed by the slave nodes' \emph{task tracker} modules (\figref{hadoop-architecture}).

\myFigureSmall{hadoop-architecture}{Hadoop's architecture}

\subsubsection{HDFS}

The Hadoop Distributed File System (HDFS) is an open-source, distributed file system, inspired by the Google File System and written specifically for Hadoop~\cite{Hadoop}. Unlike other distributed file systems (e.g.\ Lustre~\cite{Lustre}), which require expensive hardware components, HDFS was designed to run on commodity hardware.

HDFS tightly integrates with Hadoop's architecture (\figref{hdfs}). The \emph{NameNode} is responsible for storing the metadata of the files and the location of the replicas. The data is stored by the \emph{DataNode}s.

\myFigure{hdfs}{HDFS' architecture}

\subsubsection{HBase}

HBase is an open-source, distributed column family database. It is developed as part of the Hadoop project and runs on top of HDFS. The tables in an HBase database can serve as the input and the output for MapReduce jobs run in Hadoop.

\subsection{Neo4j}
\label{subsec:neo4j}

%Neo4j (\figref{neo4j-logo})
Neo4j, developed by Neo Technology, is the most popular NoSQL graph database. Neo4j implements TinkerPop's Blueprints property graph data model along with Gremlin. It also provides Cypher, a declarative query language for graph pattern matching. 

Neo4j is one of the most mature NoSQL databases. It is well documented and provides ample tooling. However, it is scalability features are limited: instead of sharding, it only supports replication of data to create a highly available cluster. Of course, the scalability limitations are a hot topic in Neo4j's development. Neo4j's developers make serious efforts to improve Neo4j's scalability in an ongoing project called Rassilon~\cite{rassilon}.

Neo4j is capable of loading graphs from \graphml{}~\cite{GraphML} and Blueprints \graphson{}~\cite{BlueprintsGraphSON} formats (see \autoref{sec:property-graph-formats} for examples). Neo4j graphs can be visualized in Neoclipse, an Eclipse RCP application~\cite{Neoclipse}. A part of a \tb{} (\autoref{sec:trainbenchmark}) instance model is shown on \figref{neoclipse-graph}.

\myFigure{neoclipse-graph}{\tb{} subgraph visualized in Neoclipse}

%\myFigure{neo4j-logo}{The logo of Neo4j}

\section{Graph technologies}

\subsection{Titan}
\label{subsec:titan}

Titan %(\figref{titan-logo}) 
is an open-source, distributed, scalable graph database from Aurelius, the creators of the TinkerPop framework. Unlike Neo4j, Titan is not a standalone database. Instead, it builds on top of existing NoSQL database technologies and leverages Hadoop's MapReduce capabilities. Titan supports various storage backends, including Cassandra and HBase.

%\myFigure{titan-logo}{The logo of Titan}

\subsubsection{Mapping and sharding}

To store the graph, Titan maps each vertex to a row of a column family (\figref{titan-cassandra-mapping}). The row stores the identifer and the properties of the vertex, along both the incoming and outgoing edges' identifiers, labels and properties.

Titan uses the storage backend's partitioner (e.g.\ Cassandra's RandomPartitioner) to shard the data. A more sophisticated partitioning system that will allow for partitioning based on the graph's static and dynamic properties (its domain and connectivity, respectively) is under implementation as of October 2013, but not yet available.

\myFigureSmall{titan-cassandra-mapping}{Titan graph vertex stored in Cassandra as a row}

\subsubsection{Deployment}

Titan can be deployed in different ways according to the needs of the application. For \iqd's prototype, we used Titan in \textit{remote server mode} (\figref{titan-modes-distributed}). In this setup, Titan runs in the same Java Virtual Machine as the application and communicates with the Cassandra cluster on a low-level protocol (e.g.\ Thrift).

\myFigure{titan-modes-distributed}{Using Titan with Cassandra in remote server mode}

\subsubsection{Faunus}

Although Titan was designed with scalability in mind, its query engine does not work in a parallel fashion. Also, it is unable to cope with queries resulting in millions of graph elements. To address this shortcoming, Aurelius developed a Hadoop-based graph analytics engine, Faunus. %(\figref{faunus-logo}).

Faunus has its own format called Faunus \graphson{}. The Faunus \graphson{} format is vertex-centric: each row represents a vertex of the graph. This way, Hadoop is able to efficiently split the input file and parallelize the load process. See \autoref{subsec:faunus-graphson} for an example.

%\myFigure{faunus-logo}{The logo of Faunus}

It is important to note that Faunus always traverses the whole graph and does not use its indices. This makes it slow for retrieving nodes or edges by type (see our typical workload at XXX).

\subsection{4store}

4store is an open-source, distributed triplestore created by Garlik~\cite{4store}. Unlike the other tools discussed earlier, 4store is written in C. While 4store is primarily applied for semantic web projects, its maturity and scalability made it an appropriate storage backend for \iqd's prototype.

Similar to Titan's partitioning, 4store's sharding mechanism (called \emph{segmenting}) distributes the RDF resources evenly across the cluster. However, unlike Titan, 4store's data model is an RDF graph. Hence, 4store's input format is RDF/OWL.

\myFigure{4s-cluster}{4store's distributed architecture~\cite{harris20094store}}

\begin{tabl}{Overview of database technologies}{database-technologies}{ | l | l | l | m{2cm} | l | m{2cm} | }
\hline
\bf Technology & 
\bf Data model & 
\bf Sharding & 
\bf Distributed operation & 
\bf DML facility & 
\bf Identifier generation \tabularnewline \hline\hline
Neo4j      & Property graph & Manual    & Manual                & Cypher       & Manual                \\ \hline
4store     & RDF            & Automatic & Manual                & SPARQL       & Manual                \\ \hline
Titan      & Property graph & Automatic & Automatic             & Gremlin      & Automatic             \\ \hline
\end{tabl}

\section{Asynchronous messaging}

Most distributed, concurrent systems use a messaging framework or message queue service. Because of the nature of the Rete algorithm (\autoref{subsec:rete}), \iqd\ requires a distributed, asynchronous messaging framework.

\subsection{Akka}
\label{subsec:akka}

%\myFigure{akka-logo}{The logo of Akka}

Akka is an open-source, fault-tolerant, distributed, asynchronous messaging framework developed by Typesafe. %(\figref{akka-logo}).
Akka is implemented in Scala, a functional and object-oriented programming language which runs on the Java Virtual Machine. Akka provides language bindings for both Java and Scala.

%\myFigure{akka-actor-path}{Determining an actor's path in Akka}

Akka provides strong support for remoting. Actors have both a logical and a physical path (\figref{akka-remote-deployment}). This way, they can be transparently moved between nodes of the cluster.

\myFigure{akka-remote-deployment}{Deploying a remote actor in Akka}

%\section{Google Guava libraries}
%\iqd{} relies heavily on Google Guava library's Collections framework~\cite{guava}. The Guava Collection is an extension to Java's Collection framework. We used both immutable collections and new type of collections (e.g.\ the \texttt{Multimap} interface and its implementations).

\section{Eclipse-based technologies}

Eclipse is a free, open-source software development environment and a platform for plug-in development. Members of the Eclipse Foundation include industry giants like IBM, Intel, Google and SAP.

\iqd{}'s single workstation predecessor, \eiq{} is built around Eclipse-based technologies. To reap the benefits of a mutual code base, we designed \iqd\ to use as much of \eiq's components as possible. In the following section, we introduce the Eclipse-based technologies most important for our work.

\subsection{EMF}
\label{subsec:EMF}

Eclipse comes with its own modeling technologies called EMF (Eclipse Modeling Framework). EMF provides a metamodel (Ecore) for designing applications and a code generation facility to produce the Java classes for the model.

\subsection{\eiq{}}
\label{subsec:eiq}

\eiq{} is developed by the Fault Tolerant Systems Research Group (FTSRG) in the Budapest University of Technology and Economics. \eiq{} is an open-source Eclipse project which provides incremental query evaluation on EMF models. The queries (graph patterns) are defined in \iq{} Pattern Language (IQPL), a domain-specific language implemented in Xtext and Xtend. \eiq{}'s architecture is shown on \figref{incquery-architecture}.

\myFigure{incquery-architecture}{\eiq{}'s architecture}

