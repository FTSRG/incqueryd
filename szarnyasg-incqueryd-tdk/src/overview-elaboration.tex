\section{Elaboration of the Example}
\label{sec:elaboration}

To demonstrate \iqd{}'s approach, we elaborate an example in detail. We introduce a case study, then formulate a query and show the workflow that executes the distributed, incremental evaluation of the pattern defined by query.

\pic{trainbenchmark-metamodel}{The EMF metamodel of the railroad system}

\subsection{Case Study: Railway System Design}
\label{subsec:casestudy}

\pic{neoclipse-graph}{A subgraph of a railroad system visualized}

The example is built around an imaginary railroad system. The system's network is composed of typical railroad items, including signals, segments, switches and sensors. The complete EMF metamodel is shown on \figref{trainbenchmark-metamodel}. A subgraph of an instance model is shown on \figref{neoclipse-graph}.

We defined queries that resemble a typical MDE application's workload. In general, MDE queries are more complex than those used in traditional databases. They often define large patterns with multiple join operations. The queries look for violations of \emph{well-formedness constraints} in the model. In this section, we discuss the \textit{RouteSensor} query in detail.
% TODO see more in the benchmark section?
%Although the \tb{} defines a total of four queries, in this report we only discuss the \textit{RouteSensor} query in detail.

\subsubsection{RouteSensor}

\pic{routesensor-pattern}{Graphical representation of the RouteSensor query's pattern. The dashed red arrow defines a negative application condition.}

The \textit{RouteSensor} query looks for \texttt{Sensor}s that are connected to a \texttt{Switch}, but the \texttt{Sensor} and the \texttt{Switch} are \emph{not} connected to the same \texttt{Route}. The graphical representation of the RouteSensor query is shown on \figref{routesensor-pattern}. Basically, the RouteSensor query binds the type of the vertices, defines three edges and one negative edge, called NAC (negative application condition). 

The RouteSensor query in IQPL (\iq{} Pattern Language) %(\autoref{subsec:eiq}) 
is shown on \lstref{routesensor-iqpl}. This query binds the variables (\texttt{Sen}, \texttt{Sw}, \texttt{Sp}, \texttt{R}) to the appropriate type. It defines the three edges as relationships between the variables and defines the negative application condition as a negative pattern (\texttt{neg find}).

For comparison, we also present the RouteSensor query in SPARQL (RDF's query language) on \lstref{routesensor-sparql}. Here, the types are defined with the \texttt{rdf:type} predicate, while the edges are defined with \texttt{base} predicates. The negative application condition is defined with the \texttt{FILTER NOT EXISTS} construction\footnote{Note that the two queries are slightly different: the SPARQL query returns only a set of \texttt{Sensor}s, while the IQPL query returns a set of (\texttt{Sensor}, \texttt{Switch}, \texttt{SwitchPosition}, \texttt{Route}) tuples.}.

\lstset{language=viatra}

\begin{lstlisting}[caption=The RouteSensor query in IQPL, label=lst:routesensor-iqpl]
package hu.bme.mit.train.constraintcheck.incquery

import "http://www.semanticweb.org/ontologies/2011/1/TrainRequirementOntology.owl" 

pattern routeSensor(Sen, Sw, Sp, R) = {
	Route(R);
	SwitchPosition(Sp);
	Switch(Sw);
	Sensor(Sen);
	
	Route.Route_switchPosition(R, Sp);
	SwitchPosition.SwitchPosition_switch(Sp, Sw);
	Trackelement.TrackElement_sensor(Sw, Sen);
	
	neg find head(Sen, R);	
}

pattern head(Sen, R) = {
	Route.Route_routeDefinition(R, Sen);
}
\end{lstlisting}


\lstset{language=SQL,morekeywords={PREFIX,FILTER}} %,java,rdf,rdfs,url,owl,base}}

\begin{lstlisting}[caption=The RouteSensor query in SPARQL, label=lst:routesensor-sparql]
PREFIX base: <http://www.semanticweb.org/ontologies/2011/1/TrainRequirementOntology.owl#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX owl:  <http://www.w3.org/2002/07/owl#>
PREFIX rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#>

SELECT DISTINCT ?xSensor
WHERE
{
    ?xRoute rdf:type base:Route .
    ?xSwitchPosition rdf:type base:SwitchPosition .
    ?xSwitch rdf:type base:Switch .
    ?xSensor rdf:type base:Sensor .
    ?xRoute base:Route_switchPosition ?xSwitchPosition .
    ?xSwitchPosition base:SwitchPosition_switch ?xSwitch .
    ?xSwitch base:TrackElement_sensor ?xSensor .

    FILTER NOT EXISTS {
        ?xRoute ?Route_routeDefinition ?xSensor .
    } .
}
\end{lstlisting}

\subsection{Workflow}

Following the workflow defined in \autoref{workflow}, we will cover the actual steps for deploying and operating a distributed pattern matcher for the \textit{RouteSensor} query.

\picSmall{recipe}{\iqd{}'s workflow} 

\subsubsection{Analyze the Metamodel and the Query}

The metamodel is shown on \figref{trainbenchmark-metamodel}. Using \eiq{}'s tooling, the textual representation (\texttt{routeSensor.arch}, see \lstref{routesensor-iqpl}) is analyzed and parsed to an EMF model (\figref{eiq-model}).

\picSmall{eiq-model}{The EMF model generated from the RouteSensor query's pattern}

\subsubsection{Build a Rete Layout}

Based on the query's EMF model, \eiq{}'s tooling builds PSystem and creates a Rete layout, that guarantees the satisfaction of the constraints. The Rete layout is shown on \figref{rete-routesensor-layout}. 
 
\pic{rete-routesensor-layout}{The RouteSensor query's layout}

\subsubsection{Allocate the Rete Network in the Cloud's Nodes} 

In \iqd{}'s current implementation, the Rete recipe's nodes are allocated manually on the cloud servers (called \textit{Machine}s). The allocation is currently defined in an architecture file (e.g.\ \texttt{routeSensor.arch}). The Rete nodes are associated with the machines with \textit{infrastructure mapping} relationships.

\iqd{}'s tooling currently provides an Eclipse-based tree editor to define machines and the infrastructure mapping edges (\figref{incqueryd-tooling-tree-editor}).

\picSmall{incqueryd-tooling-tree-editor}{The tree editor in \iqd's tooling}

The tooling is capable of visualizing the Rete network and its mapping to the machines (see \figref{incqueryd-tooling-yfiles-viewer})

\picSmall{incqueryd-tooling-yfiles-viewer}{The yFiles viewer in \iqd's tooling}

\subsubsection{Bootstrap the System}

\iqd{}'s current implementation, the distributed system is initiated with a Bash script which launches the Akka microkernel on the appropriate nodes. The Akka actors representing the Rete network's nodes are deployed automatically by the \iqd{} \textit{Coordinator} node.

\subsubsection{Rete Operation}

We demonstrate the Rete algorithm's operation on an actual instance model. Suppose we have the graph shown on the top of \figref{rete-routesensor-example-instances-neoclipse} loaded to the Rete net and we decide to delete the \texttt{ROUTE\_ROUTEDEFINITION} edge between vertices 2 and 1.

\picSmall{rete-routesensor-example-instances-neoclipse}{A modification on a \tb{} instance model}

\figref{rete-routesensor-example-rete-distributed} shows the distributed Rete net containing the partial matches of the original graph. When we delete the edge between vertices 2 and 1, the \texttt{ROUTE\_ROUTEDEFINITION} type indexer receives a notification from the middleware and sends a \textit{negative update} \textcircled{1} with the tuple $(2, 1)$. The antijoin node processes the negative update and propagates a negative update \textcircled{2} with the tuple $(3, 4, 2, 1)$. This is received by the production node, which initiates the \textit{termination protocol} \textcircled{3}, \textcircled{4}. After the termination protocol finishes, the indexer signals the client about the successful update. The client can now retrieve the results from the production node. The client may choose to retrieve only the ''deltas'', i.e.\ only the the tuples that have been added or deleted since the last modification.

\pic{rete-routesensor-example-rete-distributed}{The Rete net and the partial matches stored in its nodes}

We use the \textit{RouteSensor} query as our example. The query is shown as a graph pattern definition on \lstref{routesensor-iqpl} and visualized on \figref{routesensor-pattern}.


