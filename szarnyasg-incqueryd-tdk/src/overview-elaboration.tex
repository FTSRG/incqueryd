\section{Elaboration of the example}
\label{sec:elaboration}

Our example graph query is shown on \lstref{routesensor-iqpl} and visualized on \figref{routesensor-pattern}. 

\myFigureSmall{eiq-model}{EMF model}

\subsection{}



\subsection{Workflow}


\subsubsection{Analyze the metamodel and the query}


\subsubsection{Build a Rete layout}


\subsubsection{Allocate the Rete network in the cloud's nodes} 

\myFigureSmall{incqueryd-tooling-tree-editor}{The editor in \iqd's tooling}

\myFigureSmall{incqueryd-tooling-yfiles-viewer}{The viewer in \iqd's tooling}


\subsubsection{Bootstrap the system}
 


 
as a graph pattern definition in \eiq{} syntax~\cite{Bergmann:2010:IEM:1926458.1926467} on the left and graphically on the right. This query represents a typical pattern that is used in MDE applications (such as well-formedness validation or complex model transformations), whereby a subgraph of 4 connected vertices ($V1, V2, V3, V4$) is sought after with a \emph{negative application condition} prescribing that a typed edge (between vertices $V4$ and $V1$) must not exist.
The Rete network constructed for matching this graph pattern is depicted in \figref{retelayout}. In \iqd{}, type-instance indexers for edge types enumerate all source and target vertices, thus the intermediate join nodes perform join operations on vertex pairs that are connected by typed edges as prescribed by the definition in \figref{patterndef}. The join nodes all store the intermediate query results (e.g.\ connected $V1-V2$ and $V2-V3$ tuples in the case of the leftmost join node), and keep these caches up-to-date as change tokens arrive from the middleware (whenever model changes are performed).


