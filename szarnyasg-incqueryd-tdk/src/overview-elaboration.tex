\section{Elaboration of the example}
\label{sec:elaboration}

\subsection{Case study: railway system design}
\label{subsec:casestudy}

Due to both confidentiality and technical reasons, it is difficult to obtain real-world industrial models and queries. Also, using confidential data sets hamstrings the reproducibility of the conducted benchmarks. Therefore, we used an artificial data set which mimics real-world models.

In the following section we present the \textit{\tb{}}, a benchmark scheme and environment. The \tb{} was designed and implemented by Benedek Izsó, István Ráth and Zoltán Szatmári~\cite{ASE2013}.
%~\cite{Izso:2012:ODD:2428516.2428523, ASE2013}.
The original goal of the \tb{} was to compare various incremental and non-incremental query engines' performance to \eiq{}'s. For \iqd{}, we used an improved version of the \tb{}, which also works in a distributed environment.

\subsection{Domain}

\myFigure{trainbenchmark-metamodel}{The EMF metamodel of the \tb{}}

The \tb{} models is an imaginary railroad network. The network is composed of typical railroad items, including signals, segments, switches and sensors. The complete EMF metamodel of the \tb{} is shown on \figref{trainbenchmark-metamodel}. 

The \textit{generator} project of \tb{} is capable of generating railroad instance models of different sizes. It is capable of generating models in different formats, including EMF, OWL, RDF and SQL. 

For Neo4j (\autoref{subsec:neo4j}) and Titan (\autoref{subsec:titan}), we expanded the generator with a module that can generate property graphs based on the \tb{}'s metamodel. It supports the \graphml{}~\cite{GraphML}, the Blueprints \graphson{}~\cite{BlueprintsGraphSON} and the Faunus \graphson{}~\cite{FaunusGraphSON} output formats.

% szerintem felesleges a scenariokrol beszelni, mert csak a UserScenarioval foglalkoztunk -- SzG
% The \tb{} defines two scenarios:
% \begin{description}
%   \item[UserScenario] This scenario simulates a user sitting in front of her workstation and modifying the model in small steps.
%   \item[XFormScenario] This scenario simulates a software running automated transformations on the model.
% \end{description}

\subsection{Queries}

The \tb{} consists of queries that resemble a typical MDE application's workload. In general, MDE queries are more complex than those used in traditional databases. They often define large patterns with multiple join operations. The \tb{}'s queries look for violations of well-formedness constraints in the model. Although the \tb{} defines a total of four queries, in this report we only discuss the \textit{RouteSensor} query in detail.

\subsubsection{RouteSensor}

\myFigure{routesensor-pattern}{Graphical representation of the \emph{RouteSensor} query's pattern. The dashed red arrow defines a negative condition.}

The \textit{RouteSensor} query looks for \texttt{Sensor}s that are connected to a \texttt{Switch}, but the \texttt{Sensor} and the \texttt{Switch} are \emph{not} connected to the same \texttt{Route}. The graphical representation of the RouteSensor query is shown on \figref{routesensor-pattern}. The IQPL (\iq{} Pattern Language) query %(\autoref{subsec:eiq}) 
is shown on \lstref{routesensor-iqpl}, while the SPARQL query is shown on \lstref{routesensor-sparql}.\footnote{Note that the two queries are slightly different: the SPARQL query returns only a set of \texttt{Sensor}s, while the IQPL query returns a set of (\texttt{Sensor}, \texttt{Switch}, \texttt{SwitchPosition}, \texttt{Route}) tuples.} % TODO explain why.

\lstset{language=viatra}

\begin{lstlisting}[caption=The RouteSensor query in IQPL, label=lst:routesensor-iqpl]
package hu.bme.mit.train.constraintcheck.incquery

import "http://www.semanticweb.org/ontologies/2011/1/TrainRequirementOntology.owl" 

pattern routeSensor(Sen, Sw, Sp, R) = {
	Route(R);
	SwitchPosition(Sp);
	Switch(Sw);
	Sensor(Sen);
	
	Route.Route_switchPosition(R, Sp);
	SwitchPosition.SwitchPosition_switch(Sp, Sw);
	Trackelement.TrackElement_sensor(Sw, Sen);
	
	neg find head(Sen, R);	
}

pattern head(Sen, R) = {
	Route.Route_routeDefinition(R, Sen);
}
\end{lstlisting}


\lstset{language=SQL,morekeywords={PREFIX,FILTER}} %,java,rdf,rdfs,url,owl,base}}

\begin{lstlisting}[caption=The RouteSensor query in SPARQL, label=lst:routesensor-sparql]
PREFIX base: <http://www.semanticweb.org/ontologies/2011/1/TrainRequirementOntology.owl#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX owl:  <http://www.w3.org/2002/07/owl#>
PREFIX rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#>

SELECT DISTINCT ?xSensor
WHERE
{
    ?xRoute rdf:type base:Route .
    ?xSwitchPosition rdf:type base:SwitchPosition .
    ?xSwitch rdf:type base:Switch .
    ?xSensor rdf:type base:Sensor .
    ?xRoute base:Route_switchPosition ?xSwitchPosition .
    ?xSwitchPosition base:SwitchPosition_switch ?xSwitch .
    ?xSwitch base:TrackElement_sensor ?xSensor .

    FILTER NOT EXISTS {
        ?xRoute ?Route_routeDefinition ?xSensor .
    } .
}
\end{lstlisting}


% The Cypher implementation of the RouteSensor query is shown on %\lstrefcypher-routesensor}
% 
% \begin{lstlisting}[caption=Cyper query for the RouteSensor test case, label=lst:cypher-routesensor, breaklines=true]
% START sensor=node:node_auto_index(type="Sensor")
% MATCH sensor-[:TRACKELEMENT_SENSOR]-switch-[:SWITCHPOSITION_SWITCH]-switchPosition-[:ROUTE_SWITCHPOSITION]-route-[r?:ROUTE_ROUTEDEFINITION]-sensor
% WHERE r IS NULL
% RETURN sensor
% \end{lstlisting}




\subsection{Deployment and configuration}
\label{subsec:deployment-configuration}

Deploying, configuring and operating a distributed pattern matcher is a complex task. In the following, we will break down this task to smaller steps and present our tools for solving them. 

\subsection{Tooling}

We aimed to build \iqd{} on top of \eiq{}'s pattern language (IQPL) and its Rete net generator. For the allocation of Rete nodes, we created an Eclipse-based editor and viewer.

\subsection{Degrees of freedom}

The deployment and configuration of a distributed pattern matcher involves many degrees of freedom:

\begin{itemize}
  \item We may choose different database implementations due to the \iqd{}'s backend-agnostic nature. Until now, we experimented with property graph databases (Neo4j, Titan) and triplestores (4store).
  \item We may use different database sharding strategies (e.g.\ random partitioners or more sophisticated sharding methods based on domain-specific knowledge).
  \item We may choose different strategies to allocate the Rete nodes. Note that in theory, this is orthogonal to the database's sharding strategy. However, we expect that keeping the Rete network's type indexer nodes and the instances of the given type on the same server would improve the speed of the initialization and modification tasks significantly.
\end{itemize}
 
\subsection{Workflow}
\label{subsec:workflow}

In the following part, we will describe the workflow behind the pattern matching process. Starting from a metamodel, an instance model and a graph pattern, we will cover the problem pieces that need to be solved for setting up an incremental, distributed pattern matcher. The workflow is shown on \figref{recipe}.

\myFigureSmall{recipe}{The workflow of \eiq{} (blue) and \iqd{} (green)}

\subsubsection{Analyze the metamodel and the query}

\paragraph{Task.} First, we determine the constraints defined by the query pattern. The matches satisfying these constraints will define the results of the query.

\paragraph{Implementation.} The pattern is defined in an IQPL (\iq{} Pattern Language) text file. Using Xtext~\cite{Xtext}, an Eclipse-based framework for creating domain-specific languages, the textual representation of the pattern is parsed to an EMF model. Based on the EMF model's pattern and the metamodel, a constraint network called \textit{PSystem} (short for \textit{Pattern System}) is generated. 

\subsubsection{Build a Rete layout}

\paragraph{Task.} To allow incremental query evaluation, we create a Rete net based on the constraints derived from the query.

\paragraph{Implementation.} As we mentioned earlier, we aim to reuse as much of \eiq{}'s existing code base as possible. As part of this attempt, we introduced the concept of \textit{Rete recipe}s which define the layout of a Rete network.    

\subsubsection{Allocate the Rete network in the cloud's nodes} 

\paragraph{Task.} Because of its single workstation nature, \eiq{} simply unfolds the Rete net based on the derived Rete recipe. At the same time, \iqd{} operates in a distributed environment where local resource exhaustion, network latency and throughput are critical aspects. 

\paragraph{Implementation.} Currently, the allocation of the Rete nodes is done manually. To address this limitation, we plan to utilize CSP (Constraint Satisfaction Problem) solvers, or dynamic techniques like DSE (Design Space Exploration)~\cite{DSE11}. 

\subsubsection{Bootstrap the system}

\paragraph{Task.} Based on the Rete network's allocation, we have to deploy the Rete nodes in the distributed systems. After the successful deployment, the Rete network has to be initialized. Due to the Rete algorithm's asynchronous nature, it uses a termination protocol to signal when the data processing is finished. 

\paragraph{Implementation.} In \iqd{}'s prototype, both the bootstrapping and the Rete network's operation is carried out automatically. The Akka actors representing the Rete nodes are deployed and initiated using Akka's \textit{programmatic remote deployment} feature. For signalling the end of data processing, an asynchronous termination protocol was implemented. 





We use the \textit{RouteSensor} query as our example. The query is shown as a graph pattern definition on \lstref{routesensor-iqpl} and visualized on \figref{routesensor-pattern}. Queries like this are typical in MDE applications (such as well-formedness validation or complex model transformations).

\subsection{Workflow}

Following the workflow defined in \autoref{subsec:workflow}, we will cover the actual steps for deploying and operating a distributed pattern matcher for the \textit{RouteSensor} query.

\subsubsection{Analyze the metamodel and the query}

The metamodel is shown on \figref{trainbenchmark-metamodel}. Using \eiq{}'s tooling, the textual representation (\texttt{routeSensor.arch}, see \lstref{routesensor-iqpl}) is analyzed and parsed to an EMF model (\figref{eiq-model}).

\myFigureSmall{eiq-model}{The EMF model generated from the pattern}

\subsubsection{Build a Rete layout}

Based on the query's EMF model, \eiq{}'s tooling builds PSystem and creates a Rete layout, that guarantees the satisfaction of the constraints. The Rete layout is shown on \figref{rete-routesensor-example-rete}. 

\subsubsection{Allocate the Rete network in the cloud's nodes} 

In \iqd{}'s current implementation, the Rete recipe's nodes are allocated manually on the cloud servers (called \textit{Machine}s). The allocation is currently defined in an architecture file (e.g.\ \texttt{routeSensor.arch}). The Rete nodes are associated with the machines with \textit{infrastructure mapping} relationships.

\iqd{}'s tooling currently provides an Eclipse-based tree editor to define machines and the infrastructure mapping edges (\figref{incqueryd-tooling-tree-editor}).

\myFigureSmall{incqueryd-tooling-tree-editor}{The tree editor in \iqd's tooling}

The tooling is capable of visualizing the Rete network and its mapping to the machines (see \figref{incqueryd-tooling-yfiles-viewer})

\myFigureSmall{incqueryd-tooling-yfiles-viewer}{The yFiles viewer in \iqd's tooling}

\subsubsection{Bootstrap the system}

\iqd{}'s current implementation, the distributed system is initiated with a Bash script which launches the Akka microkernel on the appropriate nodes. The Akka actors representing the Rete network's nodes are deployed automatically by the \iqd{} \textit{Coordinator} node.
