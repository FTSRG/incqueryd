\section{Elaboration of the Example}
\label{overview-elaboration}

To demonstrate \iqd{}'s approach, we elaborate an example in detail. We introduce a case study, then formulate a query and show the workflow that executes the distributed, incremental evaluation of the pattern defined by query.

\pic{trainbenchmark-metamodel}{The EMF metamodel of the railroad system}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Case Study: Railroad System Design}
\label{railroad-system}

\picSmall{neoclipse-graph}{A subgraph of a railroad system visualized}

The example is built around an imaginary railroad system defined in the MOGENTES EU FP7 \cite{MOGENTES} project. The system's network is composed of typical railroad items, including signals, segments, switches and sensors. The complete EMF metamodel is shown on \figref{trainbenchmark-metamodel}. A subgraph of an instance model is shown on \figref{neoclipse-graph}.

We defined queries that resemble a typical MDE application's workload. In general, MDE queries are more complex than those used in traditional databases. They often define large patterns with multiple join operations. The queries look for violations of \emph{well-formedness constraints} in the model. In this section, we discuss the \textit{RouteSensor} query in detail.

% TODO see more in the benchmark section?
%Although the \tb{} defines a total of four queries, in this report we only discuss the \textit{RouteSensor} query in detail.

\subsubsection{RouteSensor}

\pic{routesensor-pattern}{Graphical representation of the RouteSensor query's pattern. The dashed red arrow defines a negative application condition.}

The \textit{RouteSensor} query looks for \texttt{Sensor}s that are connected to a \texttt{Switch}, but the \texttt{Sensor} and the \texttt{Switch} are \emph{not} connected to the same \texttt{Route}. The graphical representation of the RouteSensor query is shown on \figref{routesensor-pattern}. Basically, the RouteSensor query binds the type of the vertices, defines three edges and one negative edge, called NAC (negative application condition). 


\lstset{language=viatra}

\begin{lstlisting}[caption=The RouteSensor query in IQPL, label=lst:routesensor-iqpl]
package hu.bme.mit.train.constraintcheck.incquery

import "http://www.semanticweb.org/ontologies/2011/1/TrainRequirementOntology.owl" 

pattern routeSensor(Sen, Sw, Sp, R) = {
	Route(R);
	SwitchPosition(Sp);
	Switch(Sw);
	Sensor(Sen);
	
	Route.Route_switchPosition(R, Sp);
	SwitchPosition.SwitchPosition_switch(Sp, Sw);
	Trackelement.TrackElement_sensor(Sw, Sen);
	
	neg find head(Sen, R);	
}

pattern head(Sen, R) = {
	Route.Route_routeDefinition(R, Sen);
}
\end{lstlisting}

The RouteSensor query in IQPL (\iq{} Pattern Language) %(\autoref{subsec:eiq}) 
is shown on \lstref{routesensor-iqpl}. This query binds the variables (\texttt{Sen}, \texttt{Sw}, \texttt{Sp}, \texttt{R}) to the appropriate type. It defines the three edges as relationships between the variables and defines the negative application condition as a negative pattern (\texttt{neg find}).

For comparison, we also present the RouteSensor query in SPARQL (RDF's query language) on \lstref{routesensor-sparql}. Here, the types are defined with the \texttt{rdf:type} predicate, while the edges are defined with \texttt{base} predicates. The negative application condition is defined with the \texttt{FILTER NOT EXISTS} construction\footnote{Note that the two queries are slightly different: the SPARQL query returns only a set of \texttt{Sensor}s, while the IQPL query returns a set of (\texttt{Sensor}, \texttt{Switch}, \texttt{SwitchPosition}, \texttt{Route}) tuples.}.

\lstset{language=SQL,morekeywords={PREFIX,FILTER}} %,java,rdf,rdfs,url,owl,base}}

\begin{lstlisting}[caption=The RouteSensor query in SPARQL, label=lst:routesensor-sparql]
PREFIX base: <http://www.semanticweb.org/ontologies/2011/1/TrainRequirementOntology.owl#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX owl:  <http://www.w3.org/2002/07/owl#>
PREFIX rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#>

SELECT DISTINCT ?xSensor
WHERE
{
    ?xRoute rdf:type base:Route .
    ?xSwitchPosition rdf:type base:SwitchPosition .
    ?xSwitch rdf:type base:Switch .
    ?xSensor rdf:type base:Sensor .
    ?xRoute base:Route_switchPosition ?xSwitchPosition .
    ?xSwitchPosition base:SwitchPosition_switch ?xSwitch .
    ?xSwitch base:TrackElement_sensor ?xSensor .

    FILTER NOT EXISTS {
        ?xRoute ?Route_routeDefinition ?xSensor .
    } .
}
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\picTiny{recipe}{\iqd{}'s workflow} 

\subsection{Workflow of the Example}
\label{example-workflow}

Following the workflow defined in \autoref{iqd-workflow}, we will cover the steps for deploying and operating a distributed pattern matcher for the \textit{RouteSensor} query.

\subsubsection{Constructing a Rete network}

First, using \eiq{}'s tooling, the query (\texttt{routeSensor.iqpl}, see \lstref{routesensor-iqpl}) is analyzed and parsed to an EMF model %(\figref{eiq-model})
\textcircled{1}.

%\picTiny{eiq-model}{The EMF model generated from the RouteSensor query's pattern}

The metamodel (\texttt{railroad.ecore}) is shown on \figref{trainbenchmark-metamodel}. Based on the query \textcircled{2} and the metamodel \textcircled{3} \eiq{} builds a \emph{pattern system} (PSystem). The PSystem is translated to a Rete recipe, the system derives a Rete layout \textcircled{4}, that guarantees the satisfaction of the constraints. The Rete layout is shown on \figref{rete-routesensor-layout}.

\picSmall{rete-routesensor-layout}{The RouteSensor query's layout}

\subsubsection{Deploying the Rete network}

The Rete nodes are allocated to the cluster's servers by providing the infrastructure mapping \textcircled{5}.

%\picTiny{incqueryd-tooling-tree-editor}{The tree editor in \iqd's tooling}

In \iqd{}'s prototype, the Rete recipe's nodes are allocated manually on the cloud servers (called \textit{Machine}s). The Rete nodes are associated with the machines with \textit{infrastructure mapping} relationships. \iqd{}'s tooling currently provides an Eclipse-based tree editor to define machines and the infrastructure mapping edges.% (\figref{incqueryd-tooling-tree-editor}). 

The tooling is capable of visualizing the Rete network and its mapping to the machines (see \figref{incqueryd-tooling-yfiles-viewer}).
The Rete network is deployed to the Akka instances running on the servers \textcircled{6}.

\pic{incqueryd-tooling-yfiles-viewer}{The yFiles viewer in \iqd's tooling}

\subsubsection{Evaluating Query}

The query is evaluated by initializing the Rete network \textcircled{7} and reading the results from its production node.
%In \iqd{}'s current implementation, the distributed system is . The Akka actors representing the Rete networkwork's nodes are deployed automatically by the \iqd{} \textit{Coordinator} node.

\subsubsection{Maintaining the Query Results}

In order to provide query results that are consistent with the model, we need maintain the Rete network's state. Suppose we have the graph shown on the left side of \figref{rete-routesensor-example-instances} loaded to the Rete network and we decide to delete the \texttt{ROUTE\_ROUTEDEFINITION} edge between vertices 2 and 1.

\pic{rete-routesensor-example-instances}{A modification on a \tb{} instance model}

\figref{rete-routesensor-example-distributed} shows the distributed Rete network containing the partial matches of the original graph. When we delete the edge between vertices 2 and 1, the \texttt{ROUTE\_ROUTEDEFINITION} type indexer receives a notification from the middleware and sends a \textit{negative update} \textcircled{1} with the tuple $(2, 1)$. The antijoin node processes the negative update and propagates a negative update \textcircled{2} with the tuple $(3, 4, 2, 1)$. This is received by the production node, which initiates the \textit{termination protocol} \textcircled{3}, \textcircled{4}. After the termination protocol finishes, the indexer signals the client about the successful update. The client can now retrieve the results from the production node. The client may choose to retrieve only the ''deltas'', i.e.\ only the the tuples that have been added or deleted since the last modification.

\picSmall{rete-routesensor-example-distributed}{Operation sequence on a distributed Rete network}
