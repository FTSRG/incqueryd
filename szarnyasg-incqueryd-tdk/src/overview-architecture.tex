\section{Architecture of Incremental Queries: the Single Node Case}
\label{eiq-architecture}

In the following, we will overview the architecture of a \emph{single-node} incremental pattern matcher, specifically \eiq{}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Incremental Query Evaluation}
\label{rete}

Some queries, e.g.\ well-formedness constraints in MDE are evaluated many times, while the data sets they are evaluated on only changes to a small degree. In these cases, the idea of incremental query evaluation arises naturally: to speed up queries, we should not start the evaluation all over again. Instead, we should rely on the (partial) results derived during the previous executions of the query and process only the changes that occured.
 
In practice, incremental query evaluation algorithms typically use data structures for caching the interim results. This  means that they usually consume more memory, in other words, they trade memory consumption for execution speed. This approach, called \emph{space--time tradeoff}, is well-known and widely used in computer science.

In the following, we provide an overview of the \emph{Rete algorithm}, which forms the theoretical basis of \eiq{} and \iqd{}.

\subsubsection{Incremental Pattern Matching Algorithms}

Numerous algorithms were invented for the purpose of incremental pattern matching. Mostly, these algorithms originate from the field of rule-based expert systems.

One of the most well-known is the \emph{Rete algorithm}, which creates a propagation network, which stores the partial matches in the graph\footnote{\emph{Rete} is Latin for \emph{net}.}. TREAT \cite{Miranker:1991:OPT:627280.627434} aims at minimizing memory usage by using only indexers and dropping partial results, while having the same algorithmic complexity as Rete. Another candidate is the LEAPS \cite{Batory:1994:LA:899216} algorithm, which is claimed to provide better space--time complexity. However, we found that LEAPS is difficult to understand and implement even on a single workstation, not to mention the distributed case. 

Rete has many improved versions (e.g.\ Rete II, Rete III, Rete-NT), however, unlike the original algorithm, these are not publicly available. Because the original Rete algorithm is well-understood by the \eiq{} team, we decided to build \iqd{} on the same foundation. Experimenting with improved versions or alternative approaches is subject to future work.

\subsubsection{Rete in General}

The algorithm was originally created by Charles Forgy~\cite{Forgy} for rule-based expert systems. GÃ¡bor Bergmann  adapted the algorithm for EMF models and added many tweaks and improvements to it~\cite{BergmannMasters}.

\picSmall{rete}{The structure of the Rete propagation network}

The Rete algorithm defines an asynchronous network of communicating nodes (\figref{rete}). This is essentially a dataflow network, with two types of nodes. Change notification objects (\emph{tokens}) are propagated to intermediate \emph{worker nodes} that perform operations known from relational algebra, like projection ($ \pi $), selection ($ \sigma $),  join ($ \rhd\!\!\lhd $) and antijoin ($ \rhd $) operations. The worker nodes store partial query results in their own memory. In contrast, \emph{production nodes} are terminators that provide an interface for fetching query results and also their change sets (\emph{deltas}).

The Rete network is built on top of type-specific indexers, which are reponsible for providing quick lookups and generating notifications for the worker nodes.

\subsubsection{Termination Protocol}

As the Rete algorithm's change propagation is asynchronous, the system must also implement a \emph{termination protocol} to ensure that the query results can be retrieved consistently with the model state after a given transaction (i.e.\ by signaling when the update propagation has been terminated).

\subsubsection{Notification Mechanisms}
\label{notifications}

\emph{Model change notifications} are required by incremental query evaluation, thus model changes are captured and their effects are propagated in the form of \emph{notification objects} (NOs). The notifications generate \emph{tokens} that keep the Rete network's state consistent with the model. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Rete in \eiq{}}

The Rete algorithm forms the foundation of \eiq{}'s query engine. \figref{incquery-architecture} shows the architecture of \eiq{} and the Rete algorithm's role in the system. 

A typical model transformation sequence is the following. The modeling application manipulates the EMF instance model \textcircled{1}. The model sends notifications to \eiq{}'s base indexer \textcircled{2}. The indexer propagates the modified tuples to the Rete network as update messages \textcircled{3}, which processes the updates and sends the resulting tuples to the query evaluation interface \textcircled{4}. The modeling application can retrieve the results from the interface \textcircled{5}.

\picTiny{incquery-architecture}{\eiq{}'s architecture}

\subsubsection{Query optimization}

Similarly to optimizing query plans for relational databases, we can also optimize the Rete network's layout. Currently, \eiq{} supports basic optimizations. It utilizes node sharing, i.e.\ it detects if two Rete nodes would store the same partial matches and merges them to a single Rete node. More details are available in \cite{BergmannPhD}.

\subsubsection{Data representation}

The Rete network represents the data in \emph{tuples}. Basically, in the Rete network used in \eiq{}, the tuples can contain two sorts of values:
\begin{itemize}
  \item pointers to an EMF model,
  \item Ecore scalar values (\verb+EString+, \verb+EInt+, etc. instances).
\end{itemize}

This data representation principle intends to keep the Rete network's size as small as possible, while allowing efficient processing. Because of the tuple representation, various operations, e.g.\ projection ($ \pi $) and join ($ \rhd\!\!\lhd $), can be simply defined using tuple masks~\cite{BergmannMasters}.

\subsubsection{Workflow}
\label{eiq-workflow}

\pic{incquery-workflow}{\eiq{}'s workflow}

In the following, we describe \eiq{}'s workflow based on \figref{incquery-workflow}. 

Based on the \emph{metamodel} and the \emph{query specification}, \eiq{} first constructs a Rete network \textcircled{1} and deploys it \textcircled{2}. It loads the model (from the persistent storage) to an \emph{in-memory storage} \textcircled{3} and traverses it to initialize the Rete network's indexers. The Rete network evaluates the query by processing the incoming tuples \textcircled{4}. If the modeling application modifies the model through the EMF API, the modifications are propagated the Rete network, hence keeping it in a consistent state \textcircled{5}. The query results can be retrieved from the Rete network \textcircled{6}. The modeling application may modify the model and reevaluate the query again.
