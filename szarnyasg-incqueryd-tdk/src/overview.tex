\chapter{Overview of the Approach}
\label{chap:overview}



\section{Incremental Query Evaluation}
\label{rete}

Some queries, e.g.\ well-formedness constraints in MDE are evaluated many times, while the data sets they are evaluated on only changes to a small degree. In these cases, the idea of incremental query evaluation arises naturally: to speed up queries, we should not start the evaluation all over again. Instead, we should rely on the (partial) results derived during the previous executions of the query and process only the changes that occured.
 
In practice, incremental query evaluation algorithms typically use data structures for caching the interim results. This  means that they usually consume more memory, in other words, they trade memory consumption for execution speed. This approach, called \emph{space--time tradeoff}, is well-known and widely used in computer science.

In the following, we provide an overview of the \emph{Rete algorithm}, which forms the theoretical basis of \eiq{} and \iqd{}.

\subsection{Incremental Pattern Matching Algorithms}

Numerous algorithms were invented for the purpose of incremental pattern matching. Mostly, these algorithms originate from the field of rule-based expert systems.

One of the most well-known is the \emph{Rete algorithm}, which creates a propagation network, which stores the partial matches in the graph\footnote{\emph{Rete} is Latin for \emph{net}.}. TREAT \cite{Miranker:1991:OPT:627280.627434} aims at minimizing memory usage by using only indexers and dropping partial results, while having the same algorithmic complexity as Rete. Another candidate is the LEAPS \cite{Batory:1994:LA:899216} algorithm, which is claimed to provide better space--time complexity. However, we found that LEAPS is difficult to understand and implement even on a single workstation, not to mention the distributed case. 

Rete has many improved versions (e.g.\ Rete II, Rete III, Rete-NT), however, unlike the original algorithm, these are not publicly available. Because the original Rete algorithm is well-understood by the \eiq{} team, we decided to build \iqd{} on the same foundation. Experimenting with improved versions or alternative approaches is subject to future work.

\subsection{Rete in General}

The algorithm was originally created by Charles Forgy~\cite{Forgy} for rule-based expert systems. GÃ¡bor Bergmann  adapted the algorithm for EMF models and added many tweaks and improvements to it~\cite{BergmannMasters}.

\picSmall{rete}{The structure of the Rete propagation network}

The Rete algorithm defines an asynchronous network of communicating nodes (\figref{rete}). This is essentially a dataflow network, with two types of nodes. Change notification objects (\emph{tokens}) are propagated to intermediate \emph{worker nodes} that perform operations known from relational algebra, like projection ($ \pi $), selection ($ \sigma $),  join ($ \rhd\!\!\lhd $) and antijoin ($ \rhd $) operations. The worker nodes store partial query results in their own memory. In contrast, \emph{production nodes} are terminators that provide an interface for fetching query results and also their change sets (\emph{deltas}).

The Rete network is built on top of type-specific indexers, which are reponsible for providing quick lookups and generating notifications for the worker nodes.





\section{Incremental Pattern Matching on a Single Node: \eiq{}}
\label{eiq-architecture}

In the following, we will overview the architecture of a \emph{single-node} incremental pattern matcher, specifically \eiq{}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Architecture}

The Rete algorithm forms the foundation of \eiq{}'s query engine. \figref{incquery-architecture} shows the architecture of \eiq{} and the Rete algorithm's role in the system. 

A typical model transformation sequence is the following. The modeling application manipulates the EMF instance model \textcircled{1}. The model sends notifications to \eiq{}'s base indexer \textcircled{2}. The indexer propagates the modified tuples to the Rete network as update messages \textcircled{3}, which processes the updates and sends the resulting tuples to the query evaluation interface \textcircled{4}. The modeling application can retrieve the results from the interface \textcircled{5}.

\picTiny{incquery-architecture}{\eiq{}'s architecture}

\paragraph{Query optimization} Similarly to optimizing query plans for relational databases, we can also optimize the Rete network's layout. Currently, \eiq{} supports basic optimizations. It utilizes node sharing, i.e.\ it detects if two Rete nodes would store the same partial matches and merges them to a single Rete node. More details are available in \cite{BergmannPhD}.

\paragraph{Data representation} The Rete network represents the data in \emph{tuples}. Basically, in the Rete network used in \eiq{}, the tuples can contain two sorts of values: (i) pointers to an EMF model, (ii) Ecore scalar values (\verb+EString+, \verb+EInt+, etc. instances). This data representation principle intends to keep the Rete network's size as small as possible, while allowing efficient processing. Because of the tuple representation, various operations, e.g.\ projection ($ \pi $) and join ($ \rhd\!\!\lhd $), can be simply defined using tuple masks~\cite{BergmannMasters}.






\subsection{Notification Mechanisms}
\label{notifications}

\emph{Model change notifications} are required by incremental query evaluation, thus model changes are captured and their effects are propagated in the form of \emph{notification objects} (NOs). The notifications generate \emph{tokens} that keep the Rete network's state consistent with the model. 

\subsection{Termination Protocol}

As the Rete algorithm's change propagation is asynchronous, the system must also implement a \emph{termination protocol} to ensure that the query results can be retrieved consistently with the model state after a given transaction (i.e.\ by signaling when the update propagation has been terminated).











\section{Extensions for Distributed Scalability: \iqd{}}
\label{iqd-architecture}

Developing a distributed, scalable, incremental pattern matcher introduces numerous challenges. In the following, we will cover the \iqd{}'s architecture and its main extensions to \eiq{}.

\pic{incqueryd-architecture}{\iqd{}'s architecture on a four-node cluster}

\subsection{Architecture}

The \iqd{} architecture in an example configuration is shown in \figref{incqueryd-architecture}. \iqd{}'s architecture consists of three layers: the storage layer, the middleware and the production network. 
The \emph{storage layer} is a distributed database which is responsible for persisting the model (\autoref{storage}). 
The client application communicates with the \emph{middleware} \textcircled{1}. The middleware provides a unified API for accessing the database \textcircled{2}. It also sends change notifications \textcircled{3} (\autoref{notifications}) to the production network and retrieves the query results from the production network \textcircled{4} . 
The \emph{production network} is implemented with a distributed Rete network which provides incremental query evaluation (\autoref{rete}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Indexing and Initialization}
\label{indexing}

Indexing is a common technique for decreasing the execution time of database queries. In MDE, \emph{model indexing} is the key to high performance model queries. As MDE primarily uses a metamodeling infrastructure, all queries utilize some type attribute. In property graphs, the equivalents are node type properties and edge labels (see also \autoref{ecore-mapping}). Typical elementary model queries are the following:

\begin{itemize}
  \item Retrieving all node instances of a given type (e.g.\ get all nodes with the type \texttt{Person}).
  \item Retrieving all edges instances of a given label (e.g.\ get all edges with the label \texttt{child}).
  \item Retrieving a given node's all incoming and/or outgoing edges of a given type (e.g.\ get all outgoing \texttt{child} edges of a given node). 
  \item Reverse navigation: retrieving the node on the other end of an edge (e.g.\ the \texttt{child} relation is identical to the inverse of the \texttt{parent} relation). 
\end{itemize}

To process these queries efficiently, the \iqd{} middleware maintains type-instance indexes so that all instances of a given type (both edges and graph nodes) can be enumerated quickly. These indexers form the bottom layer of the Rete production network. During initialization, these indexers are filled from the database backend (\figref{incqueryd-architecture} \textcircled{2}). In order to reduce the initialization time, the underlying storage layer must be able to process these queries efficiently. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Storage Layer}
\label{storage}

For the storage layer, the most important issue from an incremental query evaluation perspective is that the indexers of the middleware should be filled as quickly as possible. This favors technologies where model sharding can be performed efficiently (i.e.\ with balanced shards in terms of type-instance relationships), and elementary queries can be executed efficiently.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Graph-like Data Manipulation}

\iqd{}'s middleware exposes an API that provides methods to manipulate the graph. By allowing graph-like data manipulation we allow the user to focus on the domain-specific challenges, thus increasing her productivity. The middleware translates the user's operation and forwards it to the underlying data storage (e.g.\ SPARQL queries for 4store and Gremlin queries for Titan).

\subsubsection{Data Representation}

Conceptually, the architecture of \iqd{} allows the usage of a wide scale of model representation formats. Our prototype has been evaluated in the context of the \emph{property graph} and the \emph{RDF} data model, but other mainstream metamodeling and knowledge representation languages such as relational databases' SQL dumps and Ecore instance models~\autoref{ecore} could be supported, as long as they can be mapped to an efficient and distributed storage backend (e.g.\ triplestores, key-value stores or column-family databases).

To support different data models, we only have to supply the appropriate connector class to \iqd{}'s middleware. The current prototype supports 4store, Neo4j and Titan. % Ertelemszeruen Neo4j-t a mostani verzioba nem hoztam at 100%-ig 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Degrees of Freedom}
 
The Rete algorithm (\autoref{rete}) utilizes both indexing and caching to provide fast incremental query evaluation. \iqd{}'s horizontal scalability is supported by the distribution of the pattern matcher's Rete network. To enable this, the system must be able to allocate the Rete nodes to different hosts in a cloud computing infrastructure. 

The deployment and configuration of a distributed pattern matcher involves many degrees of freedom, and design decisions. The overall performance of the system is influenced by a number of factors.

\begin{itemize}
  \item For the storage layer, we may choose different database implementations due to the \iqd{}'s backend-agnostic nature. In this report, we used property graph databases (Neo4j, Titan) and triplestores (4store).
  \item We may use different database sharding strategies (e.g.\ random partitioners or more sophisticated sharding methods based on domain-specific knowledge).
  \item Using query optimization methods, we can derive \emph{Rete networks with different layouts} for the same query. The most efficient layout can be choosen based on both query and instance model characteristics, e.g.\ to keep the resource requirement of intermediate join operations to a minimum.
  \item We may choose different strategies to \emph{allocate the Rete nodes} in the distributed system. The optimization strategy may choose to optimize local resource usage, or to minimize the amount of remote network communication. Note that in theory, this is \emph{orthogonal} to the database's sharding strategy, i.e.\ these are two distinct level of distribution that do not directly depend upon each other. However, we expect that keeping the Rete network's type indexer nodes and the instances of the given type on the same server would improve the speed of the initialization and modification tasks significantly.
  \item We may implement \emph{dynamic adaptability} to changing conditions. For example, when the model size and thus query result size grows rapidly, the Rete network may require \emph{dynamic reallocation} or \emph{node sharding} due to local resource limitations.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Notification Mechanisms}

While relational databases usually provide \emph{trigger}s for generating notifications, most triplestores and graph databases lack this feature. Among our primary database backends, 4store provides no triggers at all. Titan and Neo4j incorporate Blueprints, which provides an \texttt{EventGraph} class capable of generating notification events, but the events are only propagated in a single JVM (Java Virtual Machine). Implementing distributed notifications would require us to extend the \texttt{EventGraph} class and use a messaging framework. This is subject to future work (see \autoref{future-work}). 

Because the lack of support for distributed notifications, in \iqd{}'s prototype, notifications are controlled by the middleware by providing a facade for all model manipulation operations (\figref{incqueryd-architecture} \textcircled{3}). The notification messages are propagated through the Rete network via the Akka messaging framework. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Termination Protocol}

\iqd{}'s current termination protocol works by adding a stack to the message. The stack registers each Rete node the message passes through. After the message reaches the production node, the termination protocol starts. Based on the content of the stack, acknowledgement messages are propagated back on the network. When all relevant indexer nodes (where the original notification token(s) started from) receive the acknowledge messages, the termination protocol finishes.







\section{Tooling}

To be able to focus on the distributed aspects, of the system, we aimed to build \iqd{} on top of \eiq{}'s pattern language (IQPL) and its Rete network generator. Also, \eiq{} has an Eclipse-based user interface for defining and executing queries.

For \iqd{}, we plan to provide the same tooling environment. Also, for the allocation of Rete nodes, we created an Eclipse-based editor and viewer.

% see also http://components.neo4j.org/neo4j/snapshot/apidocs/org/neo4j/graphdb/PropertyContainer.html

%\subsection{Runtime Model-based Dashboard}
%\label{dashboard}

To aid the system's dynamic capabilities, we plan to develop a \emph{runtime model-based dashboard} to monitor the state of \iqd{}'s nodes. Currently, the \iqd{} tooling generates an architecture file (\texttt{arch}), which is used for deploying the distributed pattern matcher.

This file contains the Rete network's layout and its allocation in the cloud (as of now, the latter is defined manually). \iqd{} uses the architecture description for instantiating the Rete network and initializing the middleware (\figref{incqueryd-architecture-dashboard}).

\picTiny{incqueryd-architecture-dashboard}{Architecture of \iqd{} with a runtime dashboard}

To provide live feedback, we will adopt a \emph{live} architecture model. The live model will provide real-time details about the systems' current state, including the local resources on each server, the Rete nodes' memory consumption and so on.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Workflow}
\label{workflow}

\pic{incquery-workflow}{The general workflow of incremental pattern matching with the Rete algorithm}

In the following, we will describe the workflow behind the pattern matching process. Starting from a metamodel, an instance model and a graph pattern, we will cover the problem pieces that need to be solved for setting up an incremental, distributed pattern matcher. The workflow is shown on \figref{incquery-workflow}. First, we describe the workflow of \eiq{} and then emphasize the differences in \iqd{}'s.

\subsection{\eiq{}'s workflow}
\label{eiq-workflow}

Based on the \emph{metamodel} and the \emph{query specification}, \eiq{} first constructs a Rete network~\textcircled{1} and deploys it~\textcircled{2}. It loads the model (from the persistent storage) to an \emph{in-memory storage}~\textcircled{3} and traverses it to initialize the Rete network's indexers. The Rete network evaluates the query by processing the incoming tuples~\textcircled{4}. If the modeling application modifies the model through the EMF API, the modifications are propagated the Rete network, hence keeping it in a consistent state~\textcircled{5}. The query results can be retrieved from the Rete network~\textcircled{6}. The modeling application may modify the model and reevaluate the query again.

\subsection{\iqd{}'s workflow}
\label{iqd-workflow}

By design, \iqd{}'s workflow's steps are similar to \eiq{}'s, discussed in \autoref{eiq-workflow}. However, due to the system's distributed nature, they are more difficult to design and implement.

The main differences are the following. In \iqd{}, deploying the Rete network~\textcircled{2} requires the deployment of remote actors (\autoref{akka}) on the servers. Both the Rete indexers and the database are distributed across the cluster. Hence, loading the model and initializing the Rete network needs network communication~\textcircled{3}. The Rete network works using Akka's remote messaging feature. The query results can be retrieved from the Rete network (this may also require network communication)~\textcircled{4}. The database shards can only be accessed through the middleware, which is reponsible for sending notifications to the Rete network's appropriate indexers. After the notifications are processed and the distributed termination algorithm finishes, the Rete network is in a consistent state~\textcircled{5}. The results can be retieved by the client and it may modify the model an reevaluate the query again~\textcircled{6}. 









\section{Elaboration of the Example}
\label{overview-elaboration}

To demonstrate \iqd{}'s approach, we elaborate an example in detail. We introduce a case study, then formulate a query and show the workflow that executes the distributed, incremental evaluation of the pattern defined by query.

\pic{trainbenchmark-metamodel}{The EMF metamodel of the railroad system}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Case Study: Railroad System Design}
\label{railroad-system}

\picSmall{neoclipse-graph}{A subgraph of a railroad system visualized}

The example is built around an imaginary railroad system defined in the \mbox{MOGENTES} EU FP7 \cite{MOGENTES} project. The system's network is composed of typical railroad items, including signals, segments, switches and sensors. The complete EMF metamodel is shown on \figref{trainbenchmark-metamodel}. A subgraph of an instance model is shown on \figref{neoclipse-graph}.

We defined queries that resemble a typical MDE application's workload. In general, MDE queries are more complex than those used in traditional databases. They often define large patterns with multiple join operations. The queries look for violations of \emph{well-formedness constraints} in the model. In this section, we discuss the \textit{RouteSensor} query in detail.

% TODO see more in the benchmark section?
%Although the \tb{} defines a total of four queries, in this report we only discuss the \textit{RouteSensor} query in detail.

\subsubsection{RouteSensor}

\pic{routesensor-pattern}{Graphical representation of the RouteSensor query's pattern. The dashed red arrow defines a negative application condition.}

The \textit{RouteSensor} query looks for \texttt{Sensor}s that are connected to a \texttt{Switch}, but the \texttt{Sensor} and the \texttt{Switch} are \emph{not} connected to the same \texttt{Route}. The graphical representation of the RouteSensor query is shown on \figref{routesensor-pattern}. Basically, the RouteSensor query binds the type of the vertices, defines three edges and one negative edge, called NAC (negative application condition). 


\lstset{language=viatra}

\begin{lstlisting}[caption=The RouteSensor query in IQPL, label=lst:routesensor-iqpl]
package hu.bme.mit.train.constraintcheck.incquery

import "http://www.semanticweb.org/ontologies/2011/1/TrainRequirementOntology.owl" 

pattern routeSensor(Sen, Sw, Sp, R) = {
	Route(R);
	SwitchPosition(Sp);
	Switch(Sw);
	Sensor(Sen);
	
	Route.Route_switchPosition(R, Sp);
	SwitchPosition.SwitchPosition_switch(Sp, Sw);
	Trackelement.TrackElement_sensor(Sw, Sen);
	
	neg find head(Sen, R);	
}

pattern head(Sen, R) = {
	Route.Route_routeDefinition(R, Sen);
}
\end{lstlisting}

The RouteSensor query in IQPL (\iq{} Pattern Language) %(\autoref{subsec:eiq}) 
is shown on \lstref{routesensor-iqpl}. This query binds the variables (\texttt{Sen}, \texttt{Sw}, \texttt{Sp}, \texttt{R}) to the appropriate type. It defines the three edges as relationships between the variables and defines the negative application condition as a negative pattern (\texttt{neg find}).

For comparison, we also present the RouteSensor query in SPARQL (RDF's query language) on \lstref{routesensor-sparql}. Here, the types are defined with the \texttt{rdf:type} predicate, while the edges are defined with \texttt{base} predicates. The negative application condition is defined with the \texttt{FILTER NOT EXISTS} construction\footnote{Note that the two queries are slightly different: the SPARQL query returns only a set of \texttt{Sensor}s, while the IQPL query returns a set of (\texttt{Sensor}, \texttt{Switch}, \texttt{SwitchPosition}, \texttt{Route}) tuples.}.

\lstset{language=SQL,morekeywords={PREFIX,FILTER}} %,java,rdf,rdfs,url,owl,base}}

\begin{lstlisting}[caption=The RouteSensor query in SPARQL, label=lst:routesensor-sparql]
PREFIX base: <http://www.semanticweb.org/ontologies/2011/1/TrainRequirementOntology.owl#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX owl:  <http://www.w3.org/2002/07/owl#>
PREFIX rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#>

SELECT DISTINCT ?xSensor
WHERE
{
    ?xRoute rdf:type base:Route .
    ?xSwitchPosition rdf:type base:SwitchPosition .
    ?xSwitch rdf:type base:Switch .
    ?xSensor rdf:type base:Sensor .
    ?xRoute base:Route_switchPosition ?xSwitchPosition .
    ?xSwitchPosition base:SwitchPosition_switch ?xSwitch .
    ?xSwitch base:TrackElement_sensor ?xSensor .

    FILTER NOT EXISTS {
        ?xRoute ?Route_routeDefinition ?xSensor .
    } .
}
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\picTiny{recipe}{\iqd{}'s workflow} 

\subsection{Workflow of the Example}
\label{example-workflow}

Following the workflow defined in \autoref{iqd-workflow}, we will cover the steps for deploying and operating a distributed pattern matcher. The actual workflow for the \textit{RouteSensor} query is shown on \figref{recipe}.

\subsubsection{Constructing a Rete network}

First, using \eiq{}'s tooling, the query (\texttt{routeSensor.iqpl}, see \lstref{routesensor-iqpl}) is analyzed and parsed to an EMF model %(\figref{eiq-model})
\textcircled{1}.

%\picTiny{eiq-model}{The EMF model generated from the RouteSensor query's pattern}

The metamodel (\texttt{railroad.ecore}) is shown on \figref{trainbenchmark-metamodel}. Based on the query~\textcircled{2} and the metamodel~\textcircled{3} \eiq{} builds a \emph{pattern system} (PSystem). The PSystem is translated to a Rete recipe, the system derives a Rete layout~\textcircled{4}, that guarantees the satisfaction of the constraints. The Rete layout is shown on \figref{rete-routesensor-layout}.

\picSmall{rete-routesensor-layout}{The RouteSensor query's layout}

\subsubsection{Deploying the Rete network}

The Rete nodes are allocated to the cluster's servers by providing the infrastructure mapping~\textcircled{5}. 
%\picTiny{incqueryd-tooling-tree-editor}{The tree editor in \iqd's tooling}
In \iqd{}'s prototype, the Rete recipe's nodes are allocated manually on the cloud servers (called \textit{Machine}s). The Rete nodes are associated with the machines with \textit{infrastructure mapping} relationships. \iqd{}'s tooling currently provides an Eclipse-based tree editor to define machines and the infrastructure mapping edges.% (\figref{incqueryd-tooling-tree-editor}). 

The tooling is capable of visualizing the Rete network and its mapping to the machines (see \figref{incqueryd-tooling-yfiles-viewer}).
The Rete network is deployed to the Akka instances running on the servers~\textcircled{6}.

\pic{incqueryd-tooling-yfiles-viewer}{The yFiles viewer in \iqd's tooling}

\subsubsection{Evaluating Query}

The query is evaluated by initializing the Rete network~\textcircled{7} and reading the results from its production node.
%In \iqd{}'s current implementation, the distributed system is . The Akka actors representing the Rete networkwork's nodes are deployed automatically by the \iqd{} \textit{Coordinator} node.

\subsubsection{Maintaining the Query Results}

In order to provide query results that are consistent with the model, we need maintain the Rete network's state. Suppose we have the graph shown on the left side of \figref{rete-routesensor-example-instances} loaded to the Rete network and we decide to delete the \texttt{ROUTE\_ROUTEDEFINITION} edge between vertices 2 and 1.

\pic{rete-routesensor-example-instances}{A modification on a \tb{} instance model}

\figref{rete-routesensor-example-distributed} shows the distributed Rete network containing the partial matches of the original graph. When we delete the edge between vertices 2 and 1, the \texttt{ROUTE\_ROUTEDEFINITION} type indexer receives a notification from the middleware and sends a \textit{negative update}~\textcircled{1} with the tuple $(2, 1)$. The antijoin node processes the negative update and propagates a negative update~\textcircled{2} with the tuple $(3, 4, 2, 1)$. This is received by the production node, which initiates the \textit{termination protocol}~\textcircled{3},~\textcircled{4}. After the termination protocol finishes, the indexer signals the client about the successful update. The client can now retrieve the results from the production node. The client may choose to retrieve only the ''deltas'', i.e.\ only the the tuples that have been added or deleted since the last modification.

\picSmall{rete-routesensor-example-distributed}{Operation sequence on a distributed Rete network}

